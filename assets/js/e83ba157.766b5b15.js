"use strict";(self.webpackChunkdocassemble_assembly_line_documentation=self.webpackChunkdocassemble_assembly_line_documentation||[]).push([[7829],{2171:(n,e,a)=>{a.r(e),a.d(e,{assets:()=>o,contentTitle:()=>r,default:()=>c,frontMatter:()=>i,metadata:()=>t,toc:()=>d});const t=JSON.parse('{"id":"components/ALDashboard/translation","title":"ALDashboard.translation","description":"* ALDashboard.translation","source":"@site/docs/components/ALDashboard/translation.md","sourceDirName":"components/ALDashboard","slug":"/components/ALDashboard/translation","permalink":"/docs/components/ALDashboard/translation","draft":false,"unlisted":false,"editUrl":"https://github.com/SuffolkLITLab/docassemble-AssemblyLine-documentation/edit/main/docs/components/ALDashboard/translation.md","tags":[],"version":"current","frontMatter":{},"sidebar":"docs","previous":{"title":"ALDashboard.project_maintenance","permalink":"/docs/components/ALDashboard/project_maintenance"},"next":{"title":"ALDashboard.validate_docx","permalink":"/docs/components/ALDashboard/validate_docx"}}');var s=a(4848),l=a(8453);const i={},r="ALDashboard.translation",o={},d=[{value:"gpt_is_available",id:"gpt_is_available",level:3},{value:"may_have_mako",id:"may_have_mako",level:3},{value:"may_have_html",id:"may_have_html",level:3},{value:"translate_fragments_gpt",id:"translate_fragments_gpt",level:3},{value:"Arguments",id:"arguments",level:4},{value:"Returns",id:"returns",level:4},{value:"Translation Objects",id:"translation-objects",level:2},{value:"file: <code>DAFile</code>",id:"file-dafile",level:4},{value:"untranslated_segments: <code>int</code>",id:"untranslated_segments-int",level:4},{value:"translation_file",id:"translation_file",level:3}];function h(n){const e={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",p:"p",pre:"pre",ul:"ul",...(0,l.R)(),...n.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(e.header,{children:(0,s.jsx)(e.h1,{id:"aldashboardtranslation",children:"ALDashboard.translation"})}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.a,{href:"#ALDashboard.translation",children:"ALDashboard.translation"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:(0,s.jsx)(e.a,{href:"#ALDashboard.translation.gpt_is_available",children:"gpt_is_available"})}),"\n",(0,s.jsx)(e.li,{children:(0,s.jsx)(e.a,{href:"#ALDashboard.translation.may_have_mako",children:"may_have_mako"})}),"\n",(0,s.jsx)(e.li,{children:(0,s.jsx)(e.a,{href:"#ALDashboard.translation.may_have_html",children:"may_have_html"})}),"\n",(0,s.jsx)(e.li,{children:(0,s.jsx)(e.a,{href:"#ALDashboard.translation.translate_fragments_gpt",children:"translate_fragments_gpt"})}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.a,{href:"#ALDashboard.translation.Translation",children:"Translation"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:(0,s.jsx)(e.a,{href:"#ALDashboard.translation.Translation.file",children:"file"})}),"\n",(0,s.jsx)(e.li,{children:(0,s.jsx)(e.a,{href:"#ALDashboard.translation.Translation.untranslated_segments",children:"untranslated_segments"})}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(e.li,{children:(0,s.jsx)(e.a,{href:"#ALDashboard.translation.translation_file",children:"translation_file"})}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)("a",{id:"ALDashboard.translation.gpt_is_available"}),"\n",(0,s.jsx)(e.h3,{id:"gpt_is_available",children:"gpt_is_available"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-python",children:"def gpt_is_available() -> bool\n"})}),"\n",(0,s.jsx)(e.p,{children:"Return True if the GPT API is available."}),"\n",(0,s.jsx)("a",{id:"ALDashboard.translation.may_have_mako"}),"\n",(0,s.jsx)(e.h3,{id:"may_have_mako",children:"may_have_mako"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-python",children:"def may_have_mako(text: str) -> bool\n"})}),"\n",(0,s.jsx)(e.p,{children:"Return True if the text appears to contain any Mako code, such as ${...} or % at the beginning of a line."}),"\n",(0,s.jsx)("a",{id:"ALDashboard.translation.may_have_html"}),"\n",(0,s.jsx)(e.h3,{id:"may_have_html",children:"may_have_html"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-python",children:"def may_have_html(text: str) -> bool\n"})}),"\n",(0,s.jsx)(e.p,{children:"Return True if the text appears to contain any HTML code, such as <p> or <div>."}),"\n",(0,s.jsx)("a",{id:"ALDashboard.translation.translate_fragments_gpt"}),"\n",(0,s.jsx)(e.h3,{id:"translate_fragments_gpt",children:"translate_fragments_gpt"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-python",children:'def translate_fragments_gpt(\n        fragments: Union[str, List[Tuple[int, str]]],\n        source_language: str,\n        tr_lang: str,\n        interview_context: Optional[str] = None,\n        special_words: Optional[Dict[int, str]] = None,\n        model="gpt-4.1-nano",\n        openai_base_url: Optional[str] = None,\n        max_output_tokens: Optional[int] = None,\n        max_input_tokens: Optional[int] = None,\n        openai_api: Optional[str] = None) -> Dict[int, str]\n'})}),"\n",(0,s.jsx)(e.p,{children:"Use an AI model to translate a list of fragments (strings) from one language to another and provide a dictionary\nwith the original text and the translated text."}),"\n",(0,s.jsx)(e.p,{children:"You can optionally provide an alternative model, but it must support JSON mode."}),"\n",(0,s.jsx)(e.h4,{id:"arguments",children:"Arguments"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.code,{children:"fragments"})," - A list of strings to be translated."]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.code,{children:"source_language"})," - The language of the original text."]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.code,{children:"tr_lang"})," - The language to translate the text into."]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.code,{children:"special_words"})," - A dictionary of special words that should be translated in a specific way."]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.code,{children:"model"}),' - The GPT model to use. The default is "gpt-4.1-nano"']}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.code,{children:"openai_base_url"})," - The base URL for the OpenAI API. If not provided, the default OpenAI URL will be used."]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.code,{children:"max_output_tokens"})," - The maximum number of tokens to generate in the output."]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.code,{children:"max_input_tokens"})," - The maximum number of tokens in the input. If not provided, it will be set to 4000."]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.code,{children:"openai_api"})," - The OpenAI API key. If not provided, it will use the key from the configuration."]}),"\n"]}),"\n",(0,s.jsx)(e.h4,{id:"returns",children:"Returns"}),"\n",(0,s.jsx)(e.p,{children:"A dictionary where the keys are the indices of the fragments and the values are the translated text."}),"\n",(0,s.jsx)("a",{id:"ALDashboard.translation.Translation"}),"\n",(0,s.jsx)(e.h2,{id:"translation-objects",children:"Translation Objects"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-python",children:"class Translation(NamedTuple)\n"})}),"\n",(0,s.jsx)("a",{id:"ALDashboard.translation.Translation.file"}),"\n",(0,s.jsxs)(e.h4,{id:"file-dafile",children:["file: ",(0,s.jsx)(e.code,{children:"DAFile"})]}),"\n",(0,s.jsx)(e.p,{children:"an XLSX or XLIFF file"}),"\n",(0,s.jsx)("a",{id:"ALDashboard.translation.Translation.untranslated_segments"}),"\n",(0,s.jsxs)(e.h4,{id:"untranslated_segments-int",children:["untranslated_segments: ",(0,s.jsx)(e.code,{children:"int"})]}),"\n",(0,s.jsx)(e.p,{children:"Number of rows in the output that have untranslated text - one for each question, subquestion, field, etc."}),"\n",(0,s.jsx)("a",{id:"ALDashboard.translation.translation_file"}),"\n",(0,s.jsx)(e.h3,{id:"translation_file",children:"translation_file"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-python",children:"def translation_file(yaml_filename: str,\n                     tr_lang: str,\n                     use_gpt=False,\n                     use_google_translate=False,\n                     openai_api: Optional[str] = None,\n                     max_tokens=4000,\n                     interview_context: Optional[str] = None,\n                     special_words: Optional[Dict[int, str]] = None,\n                     model: Optional[str] = None,\n                     openai_base_url: Optional[str] = None,\n                     max_input_tokens: Optional[int] = None,\n                     max_output_tokens: Optional[int] = None) -> Translation\n"})}),"\n",(0,s.jsx)(e.p,{children:"Return a tuple of the translation file in XLSX format, plus a count of the\nnumber of words and segments that need to be translated."}),"\n",(0,s.jsx)(e.p,{children:'The word and segment count only apply when filetype="XLSX".'}),"\n",(0,s.jsx)(e.p,{children:"This code was adjusted from the Flask endpoint-only version in server.py. XLIFF support was removed\nfor now but can be added later."})]})}function c(n={}){const{wrapper:e}={...(0,l.R)(),...n.components};return e?(0,s.jsx)(e,{...n,children:(0,s.jsx)(h,{...n})}):h(n)}},8453:(n,e,a)=>{a.d(e,{R:()=>i,x:()=>r});var t=a(6540);const s={},l=t.createContext(s);function i(n){const e=t.useContext(l);return t.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function r(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(s):n.components||s:i(n.components),t.createElement(l.Provider,{value:e},n.children)}}}]);