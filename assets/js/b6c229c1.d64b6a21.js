"use strict";(self.webpackChunkdocassemble_assembly_line_documentation=self.webpackChunkdocassemble_assembly_line_documentation||[]).push([[5520],{4137:(e,t,n)=>{n.d(t,{Zo:()=>c,kt:()=>h});var a=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function l(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?l(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):l(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function i(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},l=Object.keys(e);for(a=0;a<l.length;a++)n=l[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(a=0;a<l.length;a++)n=l[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var s=a.createContext({}),u=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},c=function(e){var t=u(e.components);return a.createElement(s.Provider,{value:t},e.children)},p="mdxType",m={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},d=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,l=e.originalType,s=e.parentName,c=i(e,["components","mdxType","originalType","parentName"]),p=u(n),d=r,h=p["".concat(s,".").concat(d)]||p[d]||m[d]||l;return n?a.createElement(h,o(o({ref:t},c),{},{components:n})):a.createElement(h,o({ref:t},c))}));function h(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var l=n.length,o=new Array(l);o[0]=d;var i={};for(var s in t)hasOwnProperty.call(t,s)&&(i[s]=t[s]);i.originalType=e,i[p]="string"==typeof e?e:r,o[1]=i;for(var u=2;u<l;u++)o[u]=n[u];return a.createElement.apply(null,o)}return a.createElement.apply(null,n)}d.displayName="MDXCreateElement"},6523:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>o,default:()=>p,frontMatter:()=>l,metadata:()=>i,toc:()=>u});var a=n(7462),r=(n(7294),n(4137));const l={sidebar_label:"al_courts",title:"AssemblyLine.al_courts"},o=void 0,i={unversionedId:"reference/AssemblyLine/al_courts",id:"reference/AssemblyLine/al_courts",title:"AssemblyLine.al_courts",description:"Package for a very simple / MVP list of courts that is mostly signature compatible w/ MACourts for now",source:"@site/docs/reference/AssemblyLine/al_courts.md",sourceDirName:"reference/AssemblyLine",slug:"/reference/AssemblyLine/al_courts",permalink:"/docassemble-AssemblyLine-documentation/docs/reference/AssemblyLine/al_courts",draft:!1,editUrl:"https://github.com/SuffolkLITLab/docassemble-AssemblyLine-documentation/edit/main/docs/reference/AssemblyLine/al_courts.md",tags:[],version:"current",frontMatter:{sidebar_label:"al_courts",title:"AssemblyLine.al_courts"},sidebar:"api",previous:{title:"save_input_data",permalink:"/docassemble-AssemblyLine-documentation/docs/reference/ALToolbox/save_input_data"},next:{title:"al_document",permalink:"/docassemble-AssemblyLine-documentation/docs/reference/AssemblyLine/al_document"}},s={},u=[{value:"ALCourt Objects",id:"alcourt-objects",level:2},{value:"short_label",id:"short_label",level:4},{value:"short_label_and_address",id:"short_label_and_address",level:4},{value:"short_description",id:"short_description",level:4},{value:"from_row",id:"from_row",level:4},{value:"geolocate",id:"geolocate",level:4},{value:"geocode",id:"geocode",level:4},{value:"ALCourtLoader Objects",id:"alcourtloader-objects",level:2},{value:"all_courts",id:"all_courts",level:4},{value:"unique_column_values",id:"unique_column_values",level:4},{value:"county_list",id:"county_list",level:4},{value:"county_has_one_court",id:"county_has_one_court",level:4},{value:"county_court",id:"county_court",level:4},{value:"matching_courts_in_county",id:"matching_courts_in_county",level:4},{value:"filter_courts",id:"filter_courts",level:4},{value:"as_court",id:"as_court",level:4}],c={toc:u};function p(e){let{components:t,...n}=e;return(0,r.kt)("wrapper",(0,a.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Package for a very simple / MVP list of courts that is mostly signature compatible w/ MACourts for now"),(0,r.kt)("h2",{id:"alcourt-objects"},"ALCourt Objects"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},"class ALCourt(Court)\n")),(0,r.kt)("p",null,"Object representing a court in Massachusetts.\nTODO: it could be interesting to store a jurisdiction on a court. But this is non-trivial. Should it be geo boundaries?\nA list of cities? A list of counties? Instead, we use a function on the CourtList object that filters courts by\naddress and can use any of those three features of the court to do the filtering."),(0,r.kt)("h4",{id:"short_label"},"short","_","label"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},"def short_label() -> str\n")),(0,r.kt)("p",null,"Returns a string that represents a nice, disambiguated label for the court.\nThis may not match the court","'","s name. If the name omits city, we\nappend city name to the court name. This is good for a drop-down selection\nlist."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Returns"),":"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"str")," - string representing the court","'","s name, with city if needed to disambiguate")),(0,r.kt)("h4",{id:"short_label_and_address"},"short","_","label","_","and","_","address"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},"def short_label_and_address() -> str\n")),(0,r.kt)("p",null,"Returns a markdown formatted string with the name and address of the court.\nMore concise version without description; suitable for a responsive case."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Returns"),":"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"str")," - string representing the court","'","s name and address")),(0,r.kt)("h4",{id:"short_description"},"short","_","description"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},"def short_description() -> str\n")),(0,r.kt)("p",null,"Returns a Markdown formatted string that includes the disambiguated name and\nthe description of the court, for inclusion in the results page with radio\nbuttons."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Returns"),":"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"str")," - string representing the court","'","s name and description")),(0,r.kt)("h4",{id:"from_row"},"from","_","row"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},"def from_row(df_row: pd.Series, ensure_lat_long: bool = True) -> None\n")),(0,r.kt)("p",null,"Loads data from a single Pandas Dataframe into the current court object.\nNote: It will try to convert column names that don","'","t make valid\nattributes. Best practice is to use good attribute names (no spaces) that don","'","t interfere\nwith existing attributes or methods of DAObject"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Arguments"),":"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"df_row")," - Pandas Series object"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"ensure_lat_long")," - bool, whether to use Google Maps to geocode the address if we don","'","t have coordinates")),(0,r.kt)("h4",{id:"geolocate"},"geolocate"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},"def geolocate() -> None\n")),(0,r.kt)("p",null,"Use Google Maps to geocode the court","'","s address and store the result in the location attribute."),(0,r.kt)("p",null,"Deprecated: use geocode() instead."),(0,r.kt)("h4",{id:"geocode"},"geocode"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},"def geocode() -> None\n")),(0,r.kt)("p",null,"Use Google Maps to geocode the court","'","s address and store the result in the location attribute."),(0,r.kt)("h2",{id:"alcourtloader-objects"},"ALCourtLoader Objects"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},"class ALCourtLoader(DAObject)\n")),(0,r.kt)("p",null,"Object to hold some methods surrounding loading/filtering courts."),(0,r.kt)("p",null,"Built around Pandas dataframe."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Attributes"),":"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"filename")," ",(0,r.kt)("em",{parentName:"li"},"str")," - Path to the file containing court information.")),(0,r.kt)("h4",{id:"all_courts"},"all","_","courts"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},"def all_courts() -> List[Dict[int, str]]\n")),(0,r.kt)("p",null,"Return a list of all courts in the spreadsheet."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Returns"),":"),(0,r.kt)("p",null,"  List[Dict","[int, str]","]: List of all ALCourt instances without filtering."),(0,r.kt)("h4",{id:"unique_column_values"},"unique","_","column","_","values"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},"def unique_column_values(column_name: str) -> Set[str]\n")),(0,r.kt)("p",null,"Retrieve a set of unique values present in a specified dataframe column."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Arguments"),":"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"column_name")," ",(0,r.kt)("em",{parentName:"li"},"str")," - The name of the column in the dataframe.")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Returns"),":"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"Set[str]")," - A set containing unique values from the specified column.\nReturns an empty set if an error occurs.")),(0,r.kt)("h4",{id:"county_list"},"county","_","list"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},'def county_list(column_name: str = "address_county") -> Set[str]\n')),(0,r.kt)("p",null,"Get a set of all unique names for the specified column in the given spreadsheet.\nTypically used to get a list of all possible counties that have a court."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Arguments"),":"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"column_name")," ",(0,r.kt)("em",{parentName:"li"},"str")," - The name of the column in the dataframe.")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Returns"),":"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"Set[str]")," - A list of all unique values in the specified row in the given spreadsheet")),(0,r.kt)("h4",{id:"county_has_one_court"},"county","_","has","_","one","_","court"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},'def county_has_one_court(county_name: str,\n                         county_column: str = "address_county") -> bool\n')),(0,r.kt)("p",null,"Returns True if there is only one court associated with the specified county\nin the spreadsheet. Returns False otherwise."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Arguments"),":"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"county_name")," ",(0,r.kt)("em",{parentName:"li"},"str")," - The name of the county to check."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"county_column")," ",(0,r.kt)("em",{parentName:"li"},"str")," - The name of the column in the dataframe that contains the county names.\nDefaults to ",'"',"address_county",'"',".")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Returns"),":"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"bool")," - True if there is only one court associated with the specified county in the spreadsheet.")),(0,r.kt)("h4",{id:"county_court"},"county","_","court"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},'def county_court(intrinsicName: str,\n                 county_name: str,\n                 county_column: str = "address_county") -> ALCourt\n')),(0,r.kt)("p",null,"Return the first court matching the county name. Should only be used\nwhen you know there is exactly one match"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Arguments"),":"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"intrinsicName")," ",(0,r.kt)("em",{parentName:"li"},"str")," - The intrinsic name you want the newly returned object to have (used for DA namespace searching)."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"county_name")," ",(0,r.kt)("em",{parentName:"li"},"str")," - The name of the county to check."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"county_column")," ",(0,r.kt)("em",{parentName:"li"},"str")," - The name of the column in the dataframe that contains the county names.\nDefaults to ",'"',"address_county",'"',".")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Returns"),":"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"ALCourt")," - The first court matching the county name.")),(0,r.kt)("h4",{id:"matching_courts_in_county"},"matching","_","courts","_","in","_","county"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},'def matching_courts_in_county(\n    county_name: str,\n    county_column: str = "address_county",\n    display_column: str = "name",\n    search_string: Optional[str] = None,\n    search_columns: Optional[Union[List[str], str]] = None\n) -> List[Dict[int, str]]\n')),(0,r.kt)("p",null,"Retrieve a list of all courts in the specified county."),(0,r.kt)("p",null,"This function fetches courts suitable for displaying as a drop-down or radio button list\nin Docassemble. The results are dictionaries where the key is the index in the dataframe,\nuseful for retrieving the court","'","s full details later using the as_court() method."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Arguments"),":"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"county_name")," ",(0,r.kt)("em",{parentName:"li"},"str")," - Name of the county."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"county_column")," ",(0,r.kt)("em",{parentName:"li"},"str, optional")," - Column heading which contains county name. Defaults to ",'"',"address_county",'"',"."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"display_column")," ",(0,r.kt)("em",{parentName:"li"},"str, optional")," - Column heading used for display in the drop-down. Defaults to ",'"',"name",'"',"."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"search_string")," ",(0,r.kt)("em",{parentName:"li"},"Optional","[str]",", optional")," - A keyword to filter the list of results. Defaults to None."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"search_columns")," ",(0,r.kt)("em",{parentName:"li"},"Optional[Union[List","[str]",", str]], optional")," - Columns to aggregate and search across with\nthe search_string in a case-insensitive manner. Defaults to None.")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Returns"),":"),(0,r.kt)("p",null,"  List[Dict","[int, str]","]: List of dictionaries representing matching courts."),(0,r.kt)("h4",{id:"filter_courts"},"filter","_","courts"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},'def filter_courts(\n    court_types: Optional[Union[List[str], str]],\n    column: str = "department",\n    display_column: str = "name",\n    search_string: Optional[str] = None,\n    search_columns: Optional[Union[List[str], str]] = None\n) -> List[Dict[int, str]]\n')),(0,r.kt)("p",null,"Return a filtered subset of courts represented as a list of dictionaries."),(0,r.kt)("p",null,"Each dictionary has the format {index: name}, where ",'"',"index",'"'," refers to the dataframe index and ",'"',"name",'"',"\nis determined by the ",(0,r.kt)("inlineCode",{parentName:"p"},"display_column"),"."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Arguments"),":"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"court_types")," ",(0,r.kt)("em",{parentName:"li"},"Optional[Union[List","[str]",", str]]")," - Exact string match or matches used to filter results\n(inclusive). Examples include ",'"',"District",'"'," or ",'["',"Municipal",'"',",",'"',"Superior",'"]',"."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"column")," ",(0,r.kt)("em",{parentName:"li"},"str, optional")," - Column heading to search. Defaults to ",'"',"department",'"',"."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"display_column")," ",(0,r.kt)("em",{parentName:"li"},"str, optional")," - Column heading used for display in the drop-down. Defaults to ",'"',"name",'"',"."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"search_string")," ",(0,r.kt)("em",{parentName:"li"},"Optional","[str]",", optional")," - A keyword to filter the list of results. Defaults to None."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"search_columns")," ",(0,r.kt)("em",{parentName:"li"},"Optional[Union[List","[str]",", str]], optional")," - Columns to aggregate and search across with\nthe search_string in a case-insensitive manner. Defaults to None.")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Returns"),":"),(0,r.kt)("p",null,"  List[Dict","[int, str]","]: List of dictionaries representing filtered courts."),(0,r.kt)("h4",{id:"as_court"},"as","_","court"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},"def as_court(intrinsicName: str,\n             index: Union[int, str],\n             ensure_lat_long: bool = True) -> ALCourt\n")),(0,r.kt)("p",null,"Retrieve the court at the specified index as an ALCourt object."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Arguments"),":"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"intrinsicName")," ",(0,r.kt)("em",{parentName:"li"},"str")," - The intrinsic name you want to assign to the returned object (used for DA namespace searching)."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"index")," ",(0,r.kt)("em",{parentName:"li"},"Union","[int, str]")," - The index position of the court in the dataframe."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"ensure_lat_long")," ",(0,r.kt)("em",{parentName:"li"},"bool, optional")," - Whether to ensure the presence of latitude and longitude data. Defaults to True.")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Returns"),":"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"ALCourt")," - An ALCourt object initialized with data from the specified index.")))}p.isMDXComponent=!0}}]);